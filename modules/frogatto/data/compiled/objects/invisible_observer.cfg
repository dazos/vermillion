{
	"animation": [
		{
			"id": "normal",
			"image": "characters/stand_in_selector.png",
			"rect": [0,0,15,15]
		}
	],
	"consts": {
		"posthit_invicibility_period": 100
	},
	"editor_info": null,
	"functions": ["#Function to do a water-equivalent of standing.#
	  def float(object_type obj)
		animation('swim_side_idle')"],
	"hidden_in_game": true,
	"id": "invisible_observer",
	"is_human": true,
	"mass": 5,
	"no_move_to_standing": true,
	"on_add_object_fail": "[if(collide_with.team != team and collide_with.get_hit_by, collide_with.get_hit_by(me)), die()]",
	"on_change_animation_failure": "fire_event('solidity_fail')",
	"on_change_solid_dimensions_fail": "if(not is_invincible_posthit,
	                    [add(hitpoints, -1), set(vars.time_last_hit, cycle)])",
	"on_collide_damage": "[if((not is_invincible), [add(hitpoints, -max(1, surface_damage)), cause_flinch(collide_with), display_hurt_visuals(), set(vars.time_last_hit, cycle), set(solid_dimensions_in, ['player'])])]",
	"on_collide_object_body": "if(collide_with.team != team and collide_with.team != 'evil_harmless' and (not (collide_with.team = 'evil' and team = 'evil_harmless')), if(collide_with_area in ['attack','thrown'], get_hit_by(collide_with)))",
	"on_ctrl_jump": "if(is_standing and (not (animation in ['interact', 'fall', 'jump'])), [
    animation('jump'),
    if(not ctrl_down or underwater, [ set(jumpCloud.parent, self.standing_on),
    add_object(jumpCloud),
    ] where jumpCloud = object('dust_cloud_jump', midpoint_x, y2 - 22, facing)),
    set(velocity_x, velocity_x + velocity_x/2),
    if(ctrl_down and is_standing_on_platform,
        [set(fall_through_platforms, 10),
        set(velocity_y, velocity_y + jump_power/10)],
        [set(velocity_y, -jump_power),
        add(velocity_x, velocity_x/2)])])",
	"on_ctrl_up": "[
	if(abs(velocity_x) < 100 and is_standing, map(filter(level.active_chars, 'char', collides(context.me, 'body', char, 'interact')), 'obj', [set(tmp.interacting_with, obj), fire_event(obj, 'interact')]))]",
	"on_end_hurt_anim": "animation('stand')",
	"on_end_interact_anim": "animation('stand')",
	"on_enter_stand_anim": "if(abs(slope_standing_on) > 20, stand(self))",
	"on_enter_stand_down_slope_anim": "if(slope_standing_on*facing < 20, stand(self))",
	"on_enter_stand_up_slope_anim": "if(slope_standing_on*facing > -20, stand(self))",
	"on_handle_move_script": "if(abs(midpoint_x - tmp.scripted_target_x) < 10,
		  if(abs(tmp.scripted_target_facing) = 1 and facing != tmp.scripted_target_facing,
		  [set(control_lock, if(tmp.scripted_target_facing > 0, ['ctrl_right'], ['ctrl_left'])), schedule(1, fire_event('handle_move_script'))],

		  [set(control_lock, null),
		   set(me.tmp.scripted_target_x, null),
		   set(me.tmp.scripted_target_facing, null),
		   set(me.tmp.scripted_move_callback, null),
		   tmp.scripted_move_callback]),
	   
		[set(control_lock, if(tmp.scripted_target_x > midpoint_x, ['ctrl_right'], ['ctrl_left'])), schedule(1, fire_event('handle_move_script'))])",
	"on_hittable_PROTO_change_solid_dimensions_fail": "fire_event('solidity_fail')",
	"on_interacting": "if(tmp.interacting_with and tmp.fired_talk = 0, [set(tmp.fired_talk, 1), fire_event(tmp.interacting_with, 'talk')])",
	"on_outside_level": "/*don't get hurt, because we might start outside bounds*/",
	"on_playable_PROTO_outside_level": "[if(y > level.dimensions[3], add(hitpoints,-1))]",
	"on_process_fall": "if(is_standing, if(tmp.last_standing_cycle = cycle-1, animation('stand'), set(tmp.last_standing_cycle, cycle)))",
	"on_process_jump": "if(ctrl_jump, [add(velocity_y, -vars.jump_boost)])",
	"on_return": "if(vars.target_level,
		[
		set(control_lock, []),
		screen_flash([0,0,0,0], [0,0,0,5], 50),
		schedule(50,
		  [set(vars.player.alpha, 0),
		  add(vars.player.stored_events, vars.stored_events),
	      execute(vars.player, schedule(1, set(brightness, 255))),
		  teleport(target_level,target_object,'instant',vars.player),
		  screen_flash([0,0,0,255], [0,0,0,-5], 50),
		  set(control_lock, null)]
		  )
		])",
	"on_solidity_fail": "if(tmp.in_solidity_fail, die(),
	          [set(tmp.in_solidity_fail, 1),
			   resolve_solid(me),
			   set(tmp.in_solidity_fail, 0)
			  ])",
	"on_start_interact": "[animation('interact'), set(tmp.fired_talk, 0)]",
	"on_stuck": "if(not underwater, if(not solid(level, midpoint_x, y+self.img_h-10), add(velocity_y, -vars.jump_power), add(velocity_x, if(facing=1, 300, -300))))",
	"on_surface_damage": "[fire_event('collide_damage')]",
	"on_timer": "[
#handle ending of invincibility#
	    if((cycle - vars.time_last_hit)/2 <= 50 and (cycle - vars.time_last_hit)/2 > 10, set(solid_dimensions_in, ['player', 'common', 'boss'])),
		if(not is_invincible_posthit,
		    [if(underwater and water_object.consts.damage,
				[add(hitpoints, -water_object.consts.damage), display_hurt_visuals(),
				if(water_object.type = 'acid_controller', [sound('acid.ogg'), spawn('acid_burn_particles',mid_x,mid_y,1,set(child.parent,me))]),
				 set(vars.time_last_hit, cycle)]),
			set(alpha,255)])]",
	"properties": {
		"attack_damage": 0,
		"attack_knockback": 0,
		"cause_flinch": "def(collide_with) execute(me, [
			add(me.velocity_x,me.hurt_velocity_x * sign(collide_with.midpoint_x - me.midpoint_x)), 
			add(me.velocity_y,me.hurt_velocity_y),
			cause_hurt_anim(collide_with)
			])",
		"cause_hurt_anim": "def(collide_with) execute(me, if('hurt' in available_animations,set(me.animation, 'hurt')))",
		"damage_cooldown": 0,
		"display_hurt_visuals": "def() execute(me, 
					[
					hurt_flash_sequence()
					])",
		"display_posthit_invincibility_flash_sequence": "def() if(consts.posthit_invicibility_period, 
			map(range(consts.posthit_invicibility_period/2), 'step' ,schedule(step*2, if(step%2=0,set(alpha,50),set(alpha,255))  ) ) )",
		"eval_and_exec": "def(f) [set(event_handlers.__do_stuff_eval_and_exec, f), fire_event('__do_stuff_eval_and_exec')]",
		"flash_bright": "def() [set(me.brightness, 1023)]",
		"flash_off": "def() [set(me.brightness, 255),set(me.red, 255),set(me.green, 255), set(me.blue, 255)]",
		"flash_red": "def() [set(me.red, 255),set(me.green, 100), set(me.blue, 100)]",
		"flinch_threshold": 3,
		"get_hit_by": "def(collide_with) execute(me, [
						handle_special_damage_response(collide_with),
	
						if((not is_invincible) and (collide_with.attack_damage > 0) and collide_with.hitpoints > 0 and (collide_with.attack_damage >= armor) and (collide_with.damage_cooldown < (cycle - vars.time_last_hit)),
								[display_hurt_visuals(),
								display_posthit_invincibility_flash_sequence(),
								handle_flinch(collide_with),
								handle_damage(collide_with),
								set(vars.time_last_hit, me.cycle)]),
						
						handle_damage_type(collide_with),
						handle_knockback(collide_with)])",
		"handle_damage": "def(collide_with) execute(me,[
						add(me.hitpoints, - if(me = level.player and collide_with.attack_damage_to_player, collide_with.attack_damage_to_player, collide_with.attack_damage)),
						player_damage_screen_flash(collide_with.attack_damage),
						set(solid_dimensions_in, ['player']),
						player_specific_damage_response()
					])",
		"handle_damage_type": "def(collide_with) null #virtual#",
		"handle_flinch": "def(collide_with) 
			execute(me, if(collide_with.attack_damage >= flinch_threshold, cause_flinch(collide_with)))",
		"handle_knockback": "def(collide_with) execute(me,add(velocity_x, collide_with.facing * collide_with.attack_knockback))",
		"handle_special_damage_response": "def(collide_with) null #virtual#",
		"help": "q{
Debug Console Help:
This is the debug console. Commands, which are written in FFL, are run on the
selected object. For example, you just ran the help command on our hero. Some
other commands you could try might be 'set(velocity_y, -5000)', or 'add(hp,5)'.To change the target of your actions in the console, click on the desired
object. There is a lot more you can do with FFL, so have a look at the
documentation on our wiki, https://github.com/frogatto/frogatto/wiki/. If you
get stuck, www.frogatto.com has a friendly forum where you can seek advice.
Press ctrl-d to close the console.
}",
		"higher_difficulty": "level.player.difficulty > level.player.difficulty_casual",
		"hittable_handle_damage": "def(collide_with) execute(me,add(me.hitpoints, - collide_with.attack_damage))",
		"hittable_hurt_velocity_x": -200,
		"hittable_hurt_velocity_y": -400,
		"hurt_flash_sequence": "def()	[	flash_bright(),
									schedule(3, flash_red()),
									schedule(6, flash_bright()),
									schedule(9, flash_red()),
									schedule(12, flash_bright()),
									schedule(15, flash_off())]",
		"hurt_velocity_x": 0,
		"hurt_velocity_y": -800,
		"is_invincible": "if(invincible or level.in_dialog or is_invincible_posthit, 1, 0)",
		"is_invincible_posthit": "if(vars.time_last_hit and (abs(vars.time_last_hit - me.cycle) < consts.posthit_invicibility_period), 1, 0)",
		"log_string": "def(event) [set(tmp.logged_events, new_events), debug(new_events)] where new_events = map_merge(tmp.logged_events, {(event):1})",
		"lower_difficulty": "level.player.difficulty < level.player.difficulty_challenging",
		"mana": {
			"get": "vars.mana",
			"set": "[set(vars.mana, newValue), if(newValue = 0, set(vars.mana_shock_cycle, cycle))] where newValue = median(value, 0, vars.max_mana)"
		},
		"mana_shock_active": "cycle - vars.mana_shock_cycle < mana_shock_duration",
		"mana_shock_duration": 150,
		"mana_shock_guard": "def(thingToDo) if(not mana_shock_active, thingToDo)",
		"playable_team": "'player'",
		"player_damage_screen_flash": "def(dmg_amt)
							if(dmg_amt > 2 or dmg_amt >= hitpoints, screen_flash([255, 0, 0,255], 4), if(dmg_amt = 2, screen_flash([255, 0, 0,200], 3), screen_flash([255, 0, 0,70], 2)))",
		"player_specific_damage_response": "def() null",
		"scripted_move_to_x": "def(target_x, target_facing, callback)
		                    [
		                    set(me.tmp.scripted_target_x, target_x),
							set(me.tmp.scripted_target_facing, target_facing),
							set(me.tmp.scripted_move_callback, callback),
							fire_event(me, 'handle_move_script')
							]",
		"standard_thrown_damage": 400,
		"store_event": "def(event_name, value) if(not (event_name in [null, '']),
	add(level.player.vars.stored_events, {(event_name) -> value}), [debug('error, wrote bad stored_event value')])",
		"store_event_add": "def(event_name, addend) if(not (event_name in [null, '']), set(level.player.stored_events, map_merge(level.player.vars.stored_events, {(event_name) -> addend})), [debug('error, wrote bad stored_event value')])",
		"team": "'player'"
	},
	"solid_dimensions": ["player","common","boss"],
	"timer_frequency": 2,
	"tmp": {
		"last_standing_cycle": -1,
		"left": 0,
		"logged_events": {
		},
		"lookup_time": 0,
		"right": 0,
		"scripted_move_callback": null,
		"scripted_target_facing": null,
		"scripted_target_x": null,
		"time_last_hit": 0
	},
	"variations": null,
	"vars": {
		"achievement_kill_chain": [
			[null,-1000],
			[null,-2000],
			[null,-3000],
			[null,-4000],
			[null,-4000],
			[null,-5000],
			[null,-6000],
			[null,-7000],
			[null,-8000],
			[null,-9000],
			[null,-10000],
			[null,-11000],
			[null,-12000],
			[null,-13000],
			[null,-14000],
			[null,-15000]
		],
		"levels_visited": [],
		"mana": 5000,
		"mana_shock_cycle": -150,
		"max_mana": 5000,
		"stored_events": {
		}
	},
	"vehicle": false
}